# Index란
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

# INDEX 자료구조 2가지

1) BTree
자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조 

Node와 같으며 처음엔 일정한 자식 수를 가진 '균형 트리'로 트리 중에서 특히 성능이 안정화 되어있다. 
 
그러나, B-tree 처음 생성 당시는 균형 트리이지만 테이블 갱신(INSERT/UPDATE/DELETE)의 반복을 통해 서서히 균형이 깨지고, 성능도 악화된다. 

어느 정도 자동으로 균형을 회복하는 기능이 있지만, 

insert,update,delete 빈도가 높은 테이블에 작성되는 인덱스 같은 경우 인덱스 재구성을 해서 트리의 균형을 되찾는 작업이 필요하다. 

 
2) 해시 테이블(Hash Table)
 
해시 테이블은 <b>key</b>와 <b>value</b>를 한 쌍으로 데이터를 저장하는 자료구조이다. 
(key, value)로 쌍을 표현하며, key값을 이용해 대응되는 value값을 구하는 방식이다. 해시 충돌이라는 변수가 존재하지만 평균적으로 O(1)의 매우 빠른 시간만에 원하는 데이터를 탐색할 수 있는 구조이다. 
 
해시 테이블을 이용한다면 인덱스는 (key, value) = (컬럼의 값, 데이터의 위치)로 구현하는데, 해시 테이블은 실제로 인덱스에서 잘 사용되지 않는다. 
그 이유는, 해시 테이블은 등호(=) 연산에 최적화되어있기 때문이다. 데이터베이스에선 부등호(<, >) 연산이 자주 사용되는데, 해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없다. 
 
 
# 클러스터형인덱스 vs  비클러스터형 인덱스

1)클러스터형 인덱스
테이블 당 한 개만 생성이 가능하다.(주로 PK)
테이블 자체를 인덱스로 만드는 형태이다.(리프 노드 자체가 데이터)

2)비클러스터형 인덱스
테이블당 여러개 가능하며 테이블 자체를 인덱스로 생성하지 않고 데이터를 가리키는 포인터를 사용한다.
(리프 노드는 데이터가 저장되는 위치)

# 인덱스로 설정해야 하는 컬럼 기준 4가지
1) 카디널리티가 높은 컬럼
카디널리티가 높다 = 중복도가 낮다 (ex: 주민번호,이름)
카디널리티가 낮다 = 중복도가 높다 (ex: 성별,지역)
2)선택도가 높은 컬럼
선택도가 높은 컬럼은 한컬럼이 갖고 있는 값 하나로 여러 row를 찾을 수 있다(중복도와 비슷)
3)조회 활용도
실제 작업에서 자주 사용하는 컬럼
4)수정 빈도
수정빈도가 낮은 컬럼이 인덱스 설정에 좋은 컬럼이다.

# 인덱스가 안 타는 경우
1) like 조건에서 앞에 %가 붙는경우 ex) where a= '%abc'  (<b>'abc%'는 가능</b>)
2) is null or not null
3) 컬럼 데이터 가공 ex)substr(a,2,3) , a*2
4) 부정연산자 사용 (!=,<>)
